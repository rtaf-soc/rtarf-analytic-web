# app/main.py
from fastapi import FastAPI, Depends, HTTPException, Query, status
from sqlalchemy import func
from sqlalchemy.orm import Session
from typing import List, Optional
from fastapi.middleware.cors import CORSMiddleware
from . import elastic_client
from . import database, models, crud, schemas


# ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
models.Base.metadata.create_all(bind=database.engine)

# ‡∏™‡∏£‡πâ‡∏≤‡∏á FastAPI instance
app = FastAPI(
    title="Interactive Map & RTARF API",
    description="API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏´‡∏ô‡∏î‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡∏∞ RTARF Events",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://localhost:3000"],  # üëà or specify ["http://localhost:5173"] if you use Vite
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Lifecycle event handlers
@app.on_event("startup")
async def startup_event():
    """Initialize connections on startup"""
    pass

@app.on_event("shutdown")
async def shutdown_event():
    """Close connections on shutdown"""
    await elastic_client.es.close()

# Dependency Injection
def get_db():
    db = database.SessionLocal()
    try:
        yield db
    finally:
        db.close()


# ===============================================================
# API Endpoints for Nodes
# ===============================================================

@app.post("/nodes/", 
          response_model=schemas.Node, 
          status_code=status.HTTP_201_CREATED,
          tags=["Nodes"])
def create_new_node(node: schemas.NodeCreate, db: Session = Depends(get_db)):
    """
    ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏´‡∏ô‡∏î‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö

    - **name**: ‡∏ä‡∏∑‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏ô‡∏î (required)
    - **description**: ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ (optional)
    - **node_type**: ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏ô‡∏î (required)
    - **latitude**: ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î (required)
    - **longitude**: ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î (required)
    - **ip_address**: IP address ‡∏´‡∏•‡∏±‡∏Å (optional)
    - **additional_ips**: IP addresses ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (optional)
    - **network_metadata**: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (optional)
    """
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ IP ‡∏ã‡πâ‡∏≥‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if node.ip_address:
        existing_node = crud.get_node_by_ip(db, ip_address=node.ip_address)
        if existing_node:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Node with IP address '{node.ip_address}' already exists"
            )
    
    db_node = crud.create_node(db=db, node=node)
    return schemas.Node.from_orm_with_location(db_node)


@app.get("/nodes/", 
         response_model=List[schemas.Node],
         tags=["Nodes"])
def read_all_nodes(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    node_type: Optional[str] = Query(None, description="Filter by node type"),
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ö‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤ (pagination)
    
    - **skip**: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏Ç‡πâ‡∏≤‡∏° (default: 0)
    - **limit**: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á (default: 100, max: 1000)
    - **node_type**: ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏ô‡∏î (optional)
    """
    nodes = crud.get_nodes(db, skip=skip, limit=limit, node_type=node_type)
    return [schemas.Node.from_orm_with_location(node) for node in nodes]


@app.get("/nodes/{node_id}", 
         response_model=schemas.Node,
         tags=["Nodes"])
def read_single_node(node_id: int, db: Session = Depends(get_db)):
    """
    ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏´‡∏ô‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏î‡πâ‡∏ß‡∏¢ ID
    """
    db_node = crud.get_node(db, node_id=node_id)
    if db_node is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, 
            detail=f"Node with ID {node_id} not found"
        )
    return schemas.Node.from_orm_with_location(db_node)


@app.get("/nodes/by-ip/{ip_address}",
         response_model=schemas.Node,
         tags=["Nodes"])
def read_node_by_ip(ip_address: str, db: Session = Depends(get_db)):
    """
    ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏´‡∏ô‡∏î‡∏î‡πâ‡∏ß‡∏¢ IP address
    """
    db_node = crud.get_node_by_ip(db, ip_address=ip_address)
    if db_node is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Node with IP address '{ip_address}' not found"
        )
    return schemas.Node.from_orm_with_location(db_node)


@app.put("/nodes/{node_id}",
         response_model=schemas.Node,
         tags=["Nodes"])
def update_existing_node(
    node_id: int, 
    node: schemas.NodeUpdate,  # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÄ‡∏õ‡πá‡∏ô NodeUpdate
    db: Session = Depends(get_db)
):
    """
    ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
    
    ‡∏™‡πà‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ fields ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó
    """
    db_node = crud.update_node(db, node_id=node_id, node=node)
    if db_node is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Node with ID {node_id} not found"
        )
    return schemas.Node.from_orm_with_location(db_node)


@app.delete("/nodes/{node_id}",
            status_code=status.HTTP_204_NO_CONTENT,
            tags=["Nodes"])
def delete_existing_node(node_id: int, db: Session = Depends(get_db)):
    """
    ‡∏•‡∏ö‡πÇ‡∏´‡∏ô‡∏î‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö
    
    Note: ‡∏à‡∏∞‡∏•‡∏ö connections ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏î‡πâ‡∏ß‡∏¢ (cascade delete)
    """
    success = crud.delete_node(db, node_id=node_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Node with ID {node_id} not found"
        )
    return None


@app.post("/nodes/search-by-area",
          response_model=List[schemas.Node],
          tags=["Nodes"])
def search_nodes_in_area(
    area: schemas.AreaSearchParams,
    db: Session = Depends(get_db)
):
    """
    ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÇ‡∏´‡∏ô‡∏î‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏µ‡πà‡∏¢‡∏° (bounding box)
    
    - **min_latitude**: ‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î
    - **min_longitude**: ‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î
    - **max_latitude**: ‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
    - **max_longitude**: ‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
    """
    nodes = crud.search_nodes_by_area(
        db,
        min_lat=area.min_latitude,
        min_lng=area.min_longitude,
        max_lat=area.max_latitude,
        max_lng=area.max_longitude
    )
    return [schemas.Node.from_orm_with_location(node) for node in nodes]


@app.get("/nodes/{node_id}/connections",
         response_model=schemas.NodeWithConnections,
         tags=["Nodes"])
def get_node_with_connections(
    node_id: int,
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏´‡∏ô‡∏î‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    """
    db_node = crud.get_node(db, node_id=node_id)
    if db_node is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Node with ID {node_id} not found"
        )
    
    # ‡∏î‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
    connections = crud.get_node_connections(db, node_id=node_id, direction="both")
    outgoing = [c for c in connections if c.source_node_id == node_id]
    incoming = [c for c in connections if c.destination_node_id == node_id]
    
    node_data = schemas.Node.from_orm_with_location(db_node)
    
    return schemas.NodeWithConnections(
        **node_data.dict(),
        outgoing_connections=outgoing,
        incoming_connections=incoming,
        total_outgoing=len(outgoing),
        total_incoming=len(incoming)
    )


@app.get("/nodes/{node_id}/alerts",
         response_model=schemas.NodeWithAlerts,
         tags=["Nodes"])
def get_node_with_alerts(
    node_id: int,
    limit: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏´‡∏ô‡∏î‡∏û‡∏£‡πâ‡∏≠‡∏° alerts ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
    """
    db_node = crud.get_node(db, node_id=node_id)
    if db_node is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Node with ID {node_id} not found"
        )
    
    # ‡∏î‡∏∂‡∏á alerts
    alerts = crud.get_latest_alerts_by_node(db, node_id=node_id, limit=limit)
    
    node_data = schemas.Node.from_orm_with_location(db_node)
    
    return schemas.NodeWithAlerts(
        **node_data.dict(),
        latest_alerts=alerts,
        total_alerts=len(alerts)
    )


# ===============================================================
# API Endpoints for Network Connections
# ===============================================================

@app.post("/connections/",
          response_model=schemas.NetworkConnection,
          status_code=status.HTTP_201_CREATED,
          tags=["Network Connections"])
def create_new_connection(
    connection: schemas.NetworkConnectionCreate,
    db: Session = Depends(get_db)
):
    """
    ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢‡πÉ‡∏´‡∏°‡πà
    """
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ nodes ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
    source_node = crud.get_node(db, node_id=connection.source_node_id)
    if not source_node:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Source node with ID {connection.source_node_id} not found"
        )
    
    dest_node = crud.get_node(db, node_id=connection.destination_node_id)
    if not dest_node:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Destination node with ID {connection.destination_node_id} not found"
        )
    
    db_connection = crud.create_connection(db=db, connection=connection)
    return db_connection


@app.get("/connections/",
         response_model=List[schemas.NetworkConnection],
         tags=["Network Connections"])
def read_all_connections(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    connection_type: Optional[str] = Query(None, description="Filter by connection type"),
    protocol: Optional[str] = Query(None, description="Filter by protocol"),
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡∏û‡∏£‡πâ‡∏≠‡∏° filters
    """
    connections = crud.get_connections(
        db,
        skip=skip,
        limit=limit,
        connection_type=connection_type,
        protocol=protocol
    )
    return connections


@app.get("/connections/{connection_id}",
         response_model=schemas.NetworkConnectionWithNodes,
         tags=["Network Connections"])
def read_single_connection(
    connection_id: int,
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• nodes
    """
    db_connection = crud.get_connection(db, connection_id=connection_id)
    if db_connection is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Connection with ID {connection_id} not found"
        )
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á response ‡∏û‡∏£‡πâ‡∏≠‡∏° nodes
    response_data = schemas.NetworkConnection.from_orm(db_connection)
    
    return schemas.NetworkConnectionWithNodes(
        **response_data.dict(),
        source_node=schemas.Node.from_orm_with_location(db_connection.source_node) if db_connection.source_node else None,
        destination_node=schemas.Node.from_orm_with_location(db_connection.destination_node) if db_connection.destination_node else None
    )


@app.get("/connections/node/{node_id}",
         response_model=List[schemas.NetworkConnection],
         tags=["Network Connections"])
def read_node_connections(
    node_id: int,
    direction: str = Query("both", regex="^(outgoing|incoming|both)$"),
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏ô‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞
    
    - **direction**: ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ (outgoing, incoming, both)
    """
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ node ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
    node = crud.get_node(db, node_id=node_id)
    if not node:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Node with ID {node_id} not found"
        )
    
    connections = crud.get_node_connections(db, node_id=node_id, direction=direction)
    return connections


@app.put("/connections/{connection_id}",
         response_model=schemas.NetworkConnection,
         tags=["Network Connections"])
def update_existing_connection(
    connection_id: int,
    connection: schemas.NetworkConnectionUpdate,
    db: Session = Depends(get_db)
):
    """
    ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
    """
    db_connection = crud.update_connection(db, connection_id=connection_id, connection=connection)
    if db_connection is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Connection with ID {connection_id} not found"
        )
    return db_connection


@app.post("/connections/upsert",
          response_model=schemas.NetworkConnection,
          tags=["Network Connections"])
def upsert_connection(
    connection: schemas.NetworkConnectionCreate,
    db: Session = Depends(get_db)
):
    """
    ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ
    """
    db_connection = crud.update_or_create_connection(db=db, connection=connection)
    return db_connection


@app.delete("/connections/{connection_id}",
            status_code=status.HTTP_204_NO_CONTENT,
            tags=["Network Connections"])
def delete_existing_connection(
    connection_id: int,
    db: Session = Depends(get_db)
):
    """
    ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö
    """
    success = crud.delete_connection(db, connection_id=connection_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Connection with ID {connection_id} not found"
        )
    return None


@app.get("/connections/statistics/summary",
         response_model=List[schemas.ConnectionStatistics],
         tags=["Network Connections"])
def get_connection_statistics(
    node_id: Optional[int] = Query(None, description="Filter by node ID"),
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
    """
    stats = crud.get_connection_statistics(db, node_id=node_id)
    
    return [
        schemas.ConnectionStatistics(
            protocol=stat.protocol or "unknown",
            connection_type=stat.connection_type or "unknown",
            count=stat.count,
            total_bytes_sent=stat.total_bytes_sent or 0,
            total_bytes_received=stat.total_bytes_received or 0
        )
        for stat in stats
    ]


# ===============================================================
# Network Graph Endpoints
# ===============================================================

@app.get("/network-graph",
         response_model=schemas.NetworkGraphData,
         tags=["Network Graph"])
def get_network_graph_data(
    node_type: Optional[str] = Query(None, description="Filter nodes by type"),
    connection_type: Optional[str] = Query(None, description="Filter connections by type"),
    limit_nodes: int = Query(100, ge=1, le=1000),
    limit_connections: int = Query(500, ge=1, le=5000),
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á Network Graph
    """
    nodes = crud.get_nodes(db, skip=0, limit=limit_nodes, node_type=node_type)
    connections = crud.get_connections(
        db,
        skip=0,
        limit=limit_connections,
        connection_type=connection_type
    )
    
    return schemas.NetworkGraphData(
        nodes=[schemas.Node.from_orm_with_location(node) for node in nodes],
        connections=connections
    )


# ===============================================================
# Dashboard Statistics
# ===============================================================

@app.get("/dashboard/statistics",
         response_model=schemas.DashboardStats,
         tags=["Dashboard"])
def get_dashboard_statistics(db: Session = Depends(get_db)):
    """
    ‡∏î‡∏∂‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Dashboard
    """
    # Count totals
    total_nodes = db.query(func.count(models.NodePosition.id)).scalar()
    total_connections = db.query(func.count(models.NetworkConnection.id)).scalar()
    total_events = db.query(func.count(models.RtarfEvent.id)).scalar()
    total_alerts = db.query(func.count(models.Alert.id)).scalar()
    
    # Count active connections
    active_connections = db.query(func.count(models.NetworkConnection.id)).filter(
        models.NetworkConnection.connection_status == "active"
    ).scalar()
    
    # Count suspicious connections
    suspicious_connections = db.query(func.count(models.NetworkConnection.id)).filter(
        models.NetworkConnection.connection_type == "suspicious"
    ).scalar()
    
    # Count alerts by severity
    critical_alerts = db.query(func.count(models.Alert.id)).filter(
        models.Alert.severity == "critical"
    ).scalar()
    
    high_alerts = db.query(func.count(models.Alert.id)).filter(
        models.Alert.severity == "high"
    ).scalar()
    
    medium_alerts = db.query(func.count(models.Alert.id)).filter(
        models.Alert.severity == "medium"
    ).scalar()
    
    low_alerts = db.query(func.count(models.Alert.id)).filter(
        models.Alert.severity == "low"
    ).scalar()
    
    return schemas.DashboardStats(
        total_nodes=total_nodes or 0,
        total_connections=total_connections or 0,
        total_events=total_events or 0,
        total_alerts=total_alerts or 0,
        active_connections=active_connections or 0,
        suspicious_connections=suspicious_connections or 0,
        critical_alerts=critical_alerts or 0,
        high_alerts=high_alerts or 0,
        medium_alerts=medium_alerts or 0,
        low_alerts=low_alerts or 0
    )

# ===============================================================
# API Endpoints for RTARF Events
# ===============================================================

@app.post("/rtarf-events/",
          response_model=schemas.RtarfEvent,
          status_code=status.HTTP_201_CREATED,
          tags=["RTARF Events"])
def create_new_rtarf_event(event: schemas.RtarfEventCreate, db: Session = Depends(get_db)):
    """
    ‡∏™‡∏£‡πâ‡∏≤‡∏á RTARF Event ‡πÉ‡∏´‡∏°‡πà
    """
    existing = crud.get_event(db, event_id=event.event_id)
    if existing:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Event with event_id '{event.event_id}' already exists"
        )
    return crud.create_event(db=db, event=event)


@app.get("/rtarf-events/",
         response_model=List[schemas.RtarfEvent],
         tags=["RTARF Events"])
def read_all_rtarf_events(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    severity: Optional[str] = Query(None, description="Filter by severity"),
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• RTARF Events ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    """
    return crud.get_events(db, skip=skip, limit=limit, severity=severity)


@app.get("/rtarf-events/{event_id}",
         response_model=schemas.RtarfEvent,
         tags=["RTARF Events"])
def read_single_rtarf_event(event_id: str, db: Session = Depends(get_db)):
    """
    ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• RTARF Event ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏î‡πâ‡∏ß‡∏¢ event_id
    """
    db_event = crud.get_event(db, event_id=event_id)
    if db_event is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Event with event_id '{event_id}' not found"
        )
    return db_event


@app.get("/rtarf-events/node/{node_id}",
         response_model=List[schemas.RtarfEvent],
         tags=["RTARF Events"])
def read_events_by_node(
    node_id: int,
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á events ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡πÇ‡∏´‡∏ô‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞
    """
    return crud.get_events_by_node(db, node_id=node_id, skip=skip, limit=limit)


@app.get("/rtarf-events/ip/{ip_address}",
         response_model=List[schemas.RtarfEvent],
         tags=["RTARF Events"])
def read_events_by_ip(
    ip_address: str,
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á events ‡∏à‡∏≤‡∏Å IP address
    """
    return crud.get_events_by_ip(db, ip_address=ip_address, skip=skip, limit=limit)


@app.post("/rtarf-events/sync-from-elasticsearch",
          response_model=schemas.SyncResponse,
          tags=["RTARF Events ES"])
async def query_rtarf_event(db: Session = Depends(get_db)):
    """
    Sync RTARF events from Elasticsearch to PostgreSQL
    """
    try:
        result = await crud.insert_rtarf_event_into_postgres(db, elastic_client.es)
        return result
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to sync events: {str(e)}"
        )
        
# ===============================================================
# Alert Endpoint
# ===============================================================

@app.post("/alert-lists/create-alert-from-rtarf",
          response_model=List[schemas.Alert],
          tags=["Alert lists"])
async def create_alert_from_rtarf(db: Session = Depends(get_db)):
    try:
        result = await crud.get_all_event_and_insert_into_alert(db)
        return result
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create alert lists: {str(e)}"
        )

@app.get(
    "/alert-lists/summary",
    tags=["Alert lists"]
)
async def get_alert_summary(db: Session = Depends(get_db)):
    """
    Get total alert count and grouped counts by alert_name.
    """
    try:
        result = crud.alert_summary(db)
        return result
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get alert summary: {str(e)}"
        )

@app.get("/alerts/",
         response_model=List[schemas.Alert],
         tags=["Alerts"])
def read_all_alerts(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    severity: Optional[str] = Query(None, description="Filter by severity"),
    source: Optional[str] = Query(None, description="Filter by source"),
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• alerts ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    """
    return crud.get_alerts(db, skip=skip, limit=limit, severity=severity, source=source)


@app.get("/alerts/node/{node_id}",
         response_model=List[schemas.Alert],
         tags=["Alerts"])
def read_alerts_by_node(
    node_id: int,
    limit: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á alerts ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏ô‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞
    """
    return crud.get_latest_alerts_by_node(db, node_id=node_id, limit=limit)


@app.get("/alerts/ip/{ip_address}",
         response_model=List[schemas.Alert],
         tags=["Alerts"])
def read_alerts_by_ip(
    ip_address: str,
    limit: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db)
):
    """
    ‡∏î‡∏∂‡∏á alerts ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å IP address
    """
    return crud.get_latest_alerts_by_ip(db, ip_address=ip_address, limit=limit)

# ===============================================================
# Health Check
# ===============================================================

@app.get("/health", tags=["Health"])
def health_check():
    """
    ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á API
    """
    return {"status": "healthy", "message": "API is running"}